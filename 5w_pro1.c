#include <stdio.h>

int main ()
{

    int arr[6][5] = {{1, 2, 3, 4, 5}, {6, 7, 8, 9, 10}, {11, 12, 13, 14, 15},
                      {16, 17, 18, 19, 20}, {21, 22, 23, 24, 25}, {26, 27, 28, 29, 30}};

    int row = sizeof(arr)/sizeof(arr[0]); // 행 구하기 - 배열의 전체 바이트를 열의 전체 바이트로 나누면 행의 갯수.
    int col = sizeof(arr[0])/sizeof(int); // 열 구하기 - 한 행의 전체 바이트를 자료형의 바이트로 나누면 열의 갯수.

    //printf("row: %d col: %d", row, col); // 확인.


    //이중포인터를 쓰려면 일단 기본 포인터를 먼저 생각해본다.
    //2차원 배열에서 arr[0], arr[1] .. arr[5]까지 총 6개의 행이 있다.
    //각각은 포인터로 *arr, *(arr+1) 을 통해서 행의 0번째 열의 주소값으로 접근할 수 있다.
    //주소를 가진 변수 arr에 +연산자로 정수를 더하는 것은, 그 정수의 값 * 바이트수 만큼의 바이트를 더하는 것이다.
    //즉 현재 arr은 arr[0]의 주소를 가지는 포인터변수의 주소를 가지고있다....


    // 주소 직접 확인해보기
    // for ( int i = 0; i < row ; i++)
    // {
    //     for(int j = 0; j < col ; j++)
    //     {
    //         printf("arr[%d][%d]의 주소 :  %p \n", i, j, &arr[i][j] );
    //     }
    // }

    // printf("arr[0]의 주소 :  %p \n", arr);
    // printf("arr[1]의 주소 :  %p \n", arr+1);
    // printf("arr[2]의 주소 :  %p \n", arr+2);

    // printf("arr[0]의 주소 :  %p \n", *arr);
    // printf("arr[1]의 주소 :  %p \n", *(arr+1));
    // printf("arr[2]의 주소 :  %p \n", *(arr+2));

    for ( int i = 0; i < row ; i++)
    {
        for(int j = 0; j < col ; j++)
        {
          printf("%d \t",  **(arr+i)+j  ); // **(arr+i)+j와 결과가 같다. 연산의 우선순위가 어떻게 되는 것인가? *(*(arr+i)+j)
          // https://dojang.io/mod/page/view.php?id=188 ( 연산자 우선 순위 ) 괄호가 최우선, 포인터가 덧셈보다 우선이다.
        }
        printf("\n");
    }


    // 포인터변수. 즉 주소값을 저장하고 있는 변수에는 +연산자를 사용할 수 있다.
    //가령 일차원 배열 int arr[3] = {1, 2, 3};일때. arr는 arr[0]의 주소값을 저장하고 있는 포인터변수이다.
    // arr에 +1을 붙여, arr+1 이라고 쓴다면 이것은 arr의 주소에서 단순히 1을 더하는게 아니라 4를 더한 결과값을 보여준다.
    //이를 통해서, 포인터변수에 + 연산자로 정수를 더하면, 그 포인터변수가 저장하는 주소!에 있는! 데이터의 크기만큼 곱해서 주소에 더해준다.

    //그러면 문제1처럼 이차원배열에서 arr + 1을 한다고 생각해보자. arr은 arr[0]의 주소를 가지고 있다.
    //arr[0]의 데이터 크기는 arr[0]의 배열의 크기 * 자료형byte 이다. 따라서 arr + 1은 arr[1][0]의 주소가 되는 것이다.
    // 이제부터는 일차원 배열에 포인터를 쓰는 것과 동일하다.

    //정리하자면,
    //포인터 arr은 포인터 arr[0]의 주소를 가지고 있다. 포인터 arr[0]은 arr[0][0]의 주소를 가지고 있다.
    //포인터 arr+1은 포인터 arr[1]의 주소를 가지고 있다. 포인터 arr[1]은 arr[1][0]의 주소를 가지고 있다.
    //arr[2][3]의 주소를 포인터로 어떻게 접근할까?
    //포인터 arr+2를 통해서 포인터 arr[2]의 주소로 접근한다. 포인터 arr[2]는 arr[2][0]의 주소를 가지고있다.
    // *(arr+2)는 포인터 arr+2가 가진 주소로 이동해서 그곳의 값을 나타낸다. 포인터 arr+2가 가진 주소는 포인터 arr[2]의 주소이고.
    // arr[2]가 가진 값은 arr[2][0]의 주소이다. 즉 *(arr+2)는 arr[2][0]의 주소를 가지게 된다.
    //여기서 다시 주소에 +연산을 적용해서 arr[2][0]의 주소에서 arr[2][3]의 주소로 옮겨가면 된다.
    // (*(arr+2))+3을 하면 arr[2][3]의 주소를 가지게 된다.
    //이제 여기서 *을 붙여주면 arr[2][3]의 값으로 접근한다. => *((*(arr+2))+3)

}
